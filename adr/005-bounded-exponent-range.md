# ADR 005: Bounded Exponent Range via Lookup Tables

## Status

Accepted

## Context

Dimensional analysis requires type-level integer arithmetic — when multiplying
two quantities, their exponents add; when dividing, they subtract. TypeScript
has no built-in integer arithmetic at the type level.

Two approaches exist:

1. **Recursive conditional types**: Compute results at compile time using
   recursion (e.g., Peano-style arithmetic). Supports arbitrary ranges in
   theory, but deep recursion triggers TS depth limits, produces inscrutable
   error messages, and degrades Language Server performance as the range grows.

2. **Lookup tables**: Pre-generate addition/negation tables as mapped types. A
   finite range of exponents maps to concrete results; out-of-range sums resolve
   to `never`, producing a compile-time error. Simple to generate, fast to
   resolve, and predictable error behavior.

The exponent range must cover realistic physical formulas. Most SI derived
quantities use exponents in [-3, 4] (e.g., capacitance has `T⁴`). A range of
[-6, 6] covers all standard quantities with headroom for intermediate
computations. The generator accepts a configurable max but caps it at 12 to
avoid TS LSP performance degradation.

## Decision

Use generated lookup tables (`AddTable`, `NegateExp`) for type-level exponent
arithmetic, with a default range of [-6, 6].

The `Exp` type is the union of valid exponent literals. `AddExp<A, B>` indexes
into `AddTable` for O(1) type resolution. Results outside the range resolve to
`never`, which surfaces as a type error at the call site.

The tables are generated by `scripts/generate-exponents.ts` and committed as
`exponents.generated.ts`. The range is adjustable per-project — users who need
wider exponents can regenerate with a larger max (up to 12).

```ts
export type Exp = -6 | -5 | -4 | -3 | -2 | -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6;

export type AddExp<A extends Exp, B extends Exp> = AddTable[A][B];
export type SubExp<A extends Exp, B extends Exp> = AddExp<A, Negate<B>>;
```

## Consequences

### Positive

- O(1) type resolution — no recursion, no depth limits
- Predictable TS LSP performance regardless of expression complexity
- Clear error behavior — `never` propagation produces readable type errors
- Generated from a single parameter (max), so easy to maintain and adjust

### Negative

- Finite range — operations producing exponents outside [-6, 6] fail at compile
  time even if physically meaningful
- Generated file is ~200 lines of boilerplate that must be committed
- Users needing wider ranges must fork or regenerate (not configurable at the
  type level by consumers)

### Neutral

- The default range [-6, 6] covers all standard ISQ derived quantities and most
  practical intermediate computations
- The cap of 12 is a pragmatic guard against TS performance issues, not a hard
  technical limit
